# !/usr/bin/env python

import sys
sys.path.insert(1, "/home/ross/EuPathGalaxy/Tools/lib/python/")
#sys.path.insert(0, "/opt/galaxy/tools/eupath/Tools/lib/python")
from eupath import NewEupathExporter
import optparse
import sys
import re
from subprocess import check_output

"""
python EuPathGalaxy/Tools/bin/exportSNPDataToEuPathDB TestSetDataName DataSetSummary DataSetDescription ross.madden.333934643@eupathdb.org /home/ross/EuPathGalaxy/Tools/lib/python exportToEuPathDBInfo.html /scratch/galaxy/files/016/dataset_16008.dat  SampleFileName

python EuPathGalaxy/Tools/bin/NewexportSNPDataToEuPathDB TestSetDataName DataSetSummary DataSetDescription ross.madden.333934643@eupathdb.org /home/ross/EuPathGalaxy/Tools/lib/python exportToEuPathDBInfo.html /scratch/galaxy/files/016/dataset_16008.dat  SampleFileName


args = "$dataset_name" 
    "$summary" 
    "$description"
    "$__user_email__" 
    "$__tool_directory__" 
    "$output" 
"""


def main():

    parser = optparse.OptionParser()
    (options, args) = parser.parse_args()   

    for i in args:
        print >> sys.stdout, i  

    # print >> sys.stdout, file_name    

    # So users are greeted with a bewildering traceback
    sys.tracebacklimit = 0

    # This class/function can be made in a new file where the file handler below can be created. 
    # maybe in Tools/bin/exportSNPDataToEuPathDB
    class FileValidator():
        #pass
        def __init__(self):
            self.test = [0,1,2,3]

        def validate(self, file):
            print >> sys.stdout, "File to validate: ", file
            print >> sys.stdout, "---At validate. Beep boop.---" 
            # raise ValueError('All broken!')
            # some logic for an error message. 


    class VCFFileHandler(NewEupathExporter.BaseFileHandler):
        """
        A class for handling the export of VCF file.
        The FileCollector and the Exporter can be overwritten if needed. 
        The validator should be bespoke to a file type.
        """

        # Constants
        TYPE = "VCFFile"
        VERSION = "1.0"

        def __init__(self, validator):

            self.parse_params(args)            

            NewEupathExporter.BaseFileHandler.__init__(self, 
            VCFFileHandler.TYPE, 
            VCFFileHandler.VERSION,
            NewEupathExporter.FileCollector(self._other_params[0], self._other_params[1]),
            NewEupathExporter.Exporter(self._tool_directory),
            validator,
            args
            )

            try:
                self.validation(self._other_params[0])
            except:
                raise Exception("Validation failed.")

            # print >> sys.stderr, 'Other params:', self._other_params 

        def test(self):
            # Works
            print >> sys.stdout, "_tool_directory:", self._exporter._tool_directory
            # print >> sys.stdout, "_tool_directory:", self._exporter.collect_rest_data()
            # print >> sys.stdout, "_tool_directory:", self._dataset_name  

            # Testing

            # print >> sys.stdout, "_datasetInfos:", self._filecollector._datasetInfos  
             
        def validation(self, file):
                print >> sys.stdout, "---Try validation.---"
                self._validator.validate(file)
                print >> sys.stdout, "---Validation success.---" 

        def index_and_zip(self):
            """
            If the validation is succesful this overwites the _datasetInfos with the path of the zipped and indexed file.
            This is then used for the export and the original file is left for Galaxy uses.
            """
            print >> sys.stdout, "---Zip and index.---", self._other_params[0]
            file_to_export = "New file path."
            self._filecollector._datasetInfos[0]['path'] = file_to_export
            print >> sys.stdout, self._filecollector._datasetInfos          
            return file_to_export      

    validator_class = FileValidator()

    # Makes a class composed of the validator.
    worker = VCFFileHandler(validator_class)
    worker

    worker._exporter.export(worker.index_and_zip())



    # worker.test()




    # Calls the validation method.
    # try: 
    #     worker.validation(worker._filecollector.file_path)
    #     # This file can be manually changed to export a zipped and indexed file 
    #     # The original file is left in place for user viewing/download.   
    #     # 
    #     # This will likely be dependent on the identify_dataset_files() method.
    #     print >> sys.stderr, worker.path_file_to_export    
    #     print >> sys.stderr, worker._filecollector._datasetInfos          
    #     worker._exporter.export(worker._filecollector._datasetInfos)
    # except:
    #     return Exception('Validator failed.')



if __name__ == "__main__":
    sys.exit(main())